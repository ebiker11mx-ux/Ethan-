<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Obby – Double Jump + Levels</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <style>
    html, body { width:100%; height:100%; margin:0; overflow:hidden; background:#0b0f1a; font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #renderCanvas { width:100%; height:100%; touch-action:none; display:block; }

    /* HUD */
    .hud { position:fixed; inset:0; pointer-events:none; }
    .button { position:absolute; pointer-events:auto; border:none; outline:none; color:#fff; font-weight:700; border-radius:14px;
      background:linear-gradient(135deg, #1e88e5, #6a1b9a); box-shadow:0 6px 16px rgba(0,0,0,0.4); }
    #restartBtn { top:16px; left:16px; padding:10px 14px; font-size:14px; }
    #jumpBtn { bottom:28px; right:24px; width:74px; height:74px; font-size:14px; border-radius:50%; }
    #switchMenuBtn { top:16px; left:110px; padding:10px 14px; font-size:14px; }
    #info { position:absolute; top:16px; right:16px; color:#bfe9ff; font-size:12px; background:rgba(0,0,0,0.35); padding:8px 10px; border-radius:10px;
      box-shadow:0 6px 16px rgba(0,0,0,0.3); }

    /* Win banner */
    #winBanner { position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); background:rgba(0,0,0,0.7); color:#fff;
      padding:18px 22px; border-radius:12px; font-size:18px; display:none; pointer-events:auto; box-shadow:0 10px 24px rgba(0,0,0,0.45); text-align:center; }

    /* Level picker overlay */
    #levelMenu { position:fixed; inset:0; background:rgba(3,6,14,0.8); display:flex; align-items:center; justify-content:center; backdrop-filter:blur(4px); }
    .menuCard { background:#121a2b; border-radius:16px; padding:20px; max-width:420px; width:90%; box-shadow:0 14px 36px rgba(0,0,0,0.55); text-align:center; }
    .menuTitle { color:#e6f4ff; font-weight:800; letter-spacing:0.4px; margin:0 0 12px; }
    .menuDesc { color:#b6d7ff; font-size:14px; margin-bottom:16px; }
    .levelRow { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }
    .levelBtn { flex:1 1 110px; min-width:110px; padding:12px 14px; border-radius:12px; color:#fff; font-weight:800; border:none; cursor:pointer; }
    .easy { background:linear-gradient(135deg, #2e8f5d, #3aa884); }
    .hard { background:linear-gradient(135deg, #e6a86b, #b96a1b); }
    .impossible { background:linear-gradient(135deg, #7a2b58, #c0366f); }

    /* Virtual joystick */
    #joystick { position:absolute; bottom:22px; left:22px; width:140px; height:140px; pointer-events:auto; }
    .joy-bg { position:absolute; width:100%; height:100%; border-radius:50%; background:rgba(255,255,255,0.08);
      border:2px solid rgba(255,255,255,0.15); box-shadow:inset 0 0 30px rgba(255,255,255,0.04); }
    .joy-stick { position:absolute; left:50%; top:50%; width:70px; height:70px; transform:translate(-50%, -50%);
      border-radius:50%; background:rgba(255,255,255,0.18); border:2px solid rgba(255,255,255,0.3); box-shadow:0 10px 18px rgba(0,0,0,0.35); }

    /* Small UI text */
    .small { font-size:12px; opacity:0.85; }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <div id="levelMenu">
    <div class="menuCard">
      <h2 class="menuTitle">Pick your challenge</h2>
      <p class="menuDesc">Choose Easy, Hard, or Impossible. Reach the goal as fast as you can. Double jump is enabled.</p>
      <div class="levelRow">
        <button class="levelBtn easy" data-level="easy">Easy</button>
        <button class="levelBtn hard" data-level="hard">Hard</button>
        <button class="levelBtn impossible" data-level="impossible">Impossible</button>
      </div>
      <p class="menuDesc small">Mobile: left joystick to move, Jump button to hop. Desktop: WASD/Arrows + Space.</p>
    </div>
  </div>

  <div class="hud">
    <button id="restartBtn" class="button">Restart</button>
    <button id="switchMenuBtn" class="button">Levels</button>
    <button id="jumpBtn" class="button">Jump</button>

    <div id="joystick">
      <div class="joy-bg"></div>
      <div class="joy-stick" id="joyStick"></div>
    </div>

    <div id="winBanner">You win! Time: <span id="winTime">0.0</span>s<br/><small>Tap Levels to change difficulty</small></div>
    <div id="info">Level: <span id="levelName">—</span> | Time: <span id="timer">0.0</span>s</div>
  </div>

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer:true, stencil:true });

    let scene, player, followCam;
    let currentLevel = "easy";
    let won = false, startTime = 0;

    let levelPlatforms = [];
    let movingPlatforms = [];
    let rotatingBars = [];
    let killBoxes = [];
    let goalTrigger;

    // Player state with double jump
    const playerState = {
      radius: 0.5,
      pos: new BABYLON.Vector3(0, 2, 0),
      vel: new BABYLON.Vector3(0, 0, 0),
      speed: 7.5,
      jumpPower: 10.5,
      gravity: -22.0,
      grounded: false,
      jumpsUsed: 0,        // counts jumps since last grounded
      maxJumps: 2          // double jump
    };

    const keys = { w:false, a:false, s:false, d:false, space:false };
    const joy = { active:false, dx:0, dy:0, max:55 };

    function createScene() {
      scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0.03, 0.05, 0.1, 1.0);

      // Lights
      const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
      hemi.intensity = 0.85;
      const dir = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-0.4, -0.9, -0.2), scene);
      dir.intensity = 0.5;

      // Sky
      const sky = BABYLON.MeshBuilder.CreateBox("sky", { size: 2000 }, scene);
      const skyMat = new BABYLON.StandardMaterial("skyMat", scene);
      skyMat.backFaceCulling = false;
      skyMat.emissiveColor = new BABYLON.Color3(0.02, 0.04, 0.09);
      sky.material = skyMat;

      // Player
      player = BABYLON.MeshBuilder.CreateSphere("player", { diameter: playerState.radius * 2 }, scene);
      const pMat = new BABYLON.StandardMaterial("pMat", scene);
      pMat.diffuseColor = new BABYLON.Color3(0.2, 0.8, 1.0);
      pMat.emissiveColor = new BABYLON.Color3(0.05, 0.25, 0.35);
      player.material = pMat;
      player.position.copyFrom(playerState.pos);

      // Camera follows player
      followCam = new BABYLON.FollowCamera("followCam", player.position.add(new BABYLON.Vector3(0, 6, -10)), scene);
      followCam.radius = 12;
      followCam.heightOffset = 4.5;
      followCam.cameraAcceleration = 0.06;
      followCam.maxCameraSpeed = 50;
      followCam.lockedTarget = player;
      followCam.attachControl(canvas, true);

      return scene;
    }

    function clearLevel() {
      [...levelPlatforms, ...movingPlatforms.map(m=>m.mesh), ...rotatingBars.map(r=>r.mesh), ...killBoxes, goalTrigger].forEach(mesh=>{
        if (mesh && !mesh.isDisposed()) mesh.dispose();
      });
      levelPlatforms = []; movingPlatforms = []; rotatingBars = []; killBoxes = []; goalTrigger = null;
    }

    function buildLevel(level) {
      clearLevel();
      document.getElementById("levelName").textContent = level.charAt(0).toUpperCase() + level.slice(1);

      const palette = {
        base: "#3569a4",
        alt: "#3aa884",
        move: "#e6a86b",
        bar: "#c0366f",
        goal: "#ffd85a"
      };

      // Start pad
      levelPlatforms.push(makePlatform(new BABYLON.Vector3(0, 0, 0), 14, 14, palette.base));
      let z = 10;

      if (level === "easy") {
        for (let i = 0; i < 6; i++) {
          levelPlatforms.push(makePlatform(new BABYLON.Vector3(0, 0.5, z), 6, 6, i%2?palette.base:palette.alt));
          z += 9;
        }
        const mp = makePlatform(new BABYLON.Vector3(0, 1.2, z), 6, 6, palette.move);
        movingPlatforms.push({ mesh: mp, amp: 4, speed: 1.1, phase: 0, axis: "x" }); z += 12;

        const barBase = makePlatform(new BABYLON.Vector3(0, 0.5, z), 8, 8, palette.base);
        levelPlatforms.push(barBase);
        const bar = makeBar(new BABYLON.Vector3(0, 1.6, z), 12, palette.bar);
        rotatingBars.push({ mesh: bar, speed: 1.1 }); z += 14;

        const finalPlat = makePlatform(new BABYLON.Vector3(0, 1.0, z), 10, 10, palette.alt);
        levelPlatforms.push(finalPlat);
      }

      if (level === "hard") {
        for (let i = 0; i < 5; i++) {
          const x = (i % 2 === 0) ? -3 : 3;
          levelPlatforms.push(makePlatform(new BABYLON.Vector3(x, 0.8, z), 4.2, 4.2, i%2?palette.alt:palette.base));
          z += 8;
        }
        // Two moving platforms crossing
        const mp1 = makePlatform(new BABYLON.Vector3(-4, 1.0, z), 5, 5, palette.move);
        movingPlatforms.push({ mesh: mp1, amp: 4, speed: 1.6, phase: 0, axis: "x" });
        const mp2 = makePlatform(new BABYLON.Vector3(4, 1.0, z), 5, 5, palette.move);
        movingPlatforms.push({ mesh: mp2, amp: 4, speed: 1.3, phase: Math.PI/2, axis: "z" });
        z += 12;

        // Two rotating bars
        const base1 = makePlatform(new BABYLON.Vector3(0, 0.8, z), 8, 8, palette.base);
        levelPlatforms.push(base1);
        const bar1 = makeBar(new BABYLON.Vector3(0, 1.6, z), 11, palette.bar);
        rotatingBars.push({ mesh: bar1, speed: 1.6 }); z += 12;
        const base2 = makePlatform(new BABYLON.Vector3(0, 0.8, z), 8, 8, palette.base);
        levelPlatforms.push(base2);
        const bar2 = makeBar(new BABYLON.Vector3(0, 1.6, z), 13, palette.bar);
        rotatingBars.push({ mesh: bar2, speed: -1.4 }); z += 14;

        // Narrow steps with kill gaps
        for (let i = 0; i < 6; i++) {
          const x = (i % 2 === 0) ? -2.2 : 2.2;
          levelPlatforms.push(makePlatform(new BABYLON.Vector3(x, 1.1, z), 2.6, 2.6, palette.alt));
          // kill box (gap) between steps
          killBoxes.push(makeKillBox(new BABYLON.Vector3(0, -4, z), 6, 1, 6));
          z += 6;
        }

        // Final
        const finalPlat = makePlatform(new BABYLON.Vector3(0, 1.2, z), 9, 9, palette.alt);
        levelPlatforms.push(finalPlat);
      }

      if (level === "impossible") {
        // Tiny pads, larger spacing
        for (let i = 0; i < 8; i++) {
          const x = (i % 3 === 0) ? -3.5 : (i % 3 === 1) ? 0 : 3.5;
          levelPlatforms.push(makePlatform(new BABYLON.Vector3(x, 1.3, z), 2.2, 2.2, palette.base));
          // kill pits below
          killBoxes.push(makeKillBox(new BABYLON.Vector3(0, -5, z), 16, 1, 16));
          z += 7;
        }
        // Triple moving platforms in sequence
        for (let i = 0; i < 3; i++) {
          const mp = makePlatform(new BABYLON.Vector3(0, 1.5, z), 3.2, 3.2, palette.move);
          movingPlatforms.push({ mesh: mp, amp: 6 + i*2, speed: 1.8 + i*0.2, phase: i, axis: (i%2===0?"x":"z") });
          z += 9;
        }
        // Gauntlet of rotating bars
        for (let i = 0; i < 3; i++) {
          const base = makePlatform(new BABYLON.Vector3(0, 1.0, z), 7, 7, palette.alt);
          levelPlatforms.push(base);
          const bar = makeBar(new BABYLON.Vector3(0, 1.8, z), 14 - i*2, palette.bar);
          rotatingBars.push({ mesh: bar, speed: (i%2?2.0:-2.2) });
          z += 12;
        }
        // Final micro pad
        const finalPlat = makePlatform(new BABYLON.Vector3(0, 1.6, z), 3.6, 3.6, palette.alt);
        levelPlatforms.push(finalPlat);
      }

      // Goal
      goalTrigger = BABYLON.MeshBuilder.CreateBox("goal", { width: 6, height: 2, depth: 6 }, scene);
      goalTrigger.position = new BABYLON.Vector3(0, 2.0, z);
      const goalMat = new BABYLON.StandardMaterial("goalMat", scene);
      goalMat.diffuseColor = new BABYLON.Color3(1.0, 0.85, 0.2);
      goalMat.alpha = 0.6;
      goalTrigger.material = goalMat;

      // Reset player
      resetPlayer(true);
    }

    function makePlatform(pos, w, d, colorHex) {
      const plat = BABYLON.MeshBuilder.CreateBox("plat", { width:w, height:0.8, depth:d }, scene);
      plat.position = pos.clone();
      const mat = new BABYLON.StandardMaterial("platMat", scene);
      const c = hexToColor3(colorHex);
      mat.diffuseColor = c.clone();
      mat.specularColor = new BABYLON.Color3(0.12, 0.12, 0.12);
      mat.emissiveColor = c.scale(0.08);
      plat.material = mat;
      return plat;
    }

    function makeBar(pos, length, colorHex) {
      const bar = BABYLON.MeshBuilder.CreateBox("rotBar", { width: 1.0, height: 0.6, depth: length }, scene);
      bar.position = pos.clone();
      const barMat = new BABYLON.StandardMaterial("barMat", scene);
      const c = hexToColor3(colorHex);
      barMat.diffuseColor = c.clone(); barMat.emissiveColor = c.scale(0.12);
      bar.material = barMat;
      return bar;
    }

    function makeKillBox(pos, w, h, d) {
      const kill = BABYLON.MeshBuilder.CreateBox("kill", { width:w, height:h, depth:d }, scene);
      kill.position = pos.clone();
      const m = new BABYLON.StandardMaterial("killMat", scene);
      m.diffuseColor = new BABYLON.Color3(0.02,0.02,0.02);
      m.alpha = 0.0; // invisible pit
      kill.material = m;
      return kill;
    }

    function hexToColor3(hex) {
      const h = hex.replace("#", "");
      return new BABYLON.Color3(parseInt(h.substring(0,2),16)/255, parseInt(h.substring(2,4),16)/255, parseInt(h.substring(4,6),16)/255);
    }

    // Collision: sphere support on top of AABB
    function sphereVsAABB_YSupport(spherePos, radius, box) {
      const b = box.getBoundingInfo().boundingBox;
      const min = b.minimumWorld, max = b.maximumWorld;
      const cx = Math.max(min.x, Math.min(spherePos.x, max.x));
      const cy = Math.max(min.y, Math.min(spherePos.y, max.y));
      const cz = Math.max(min.z, Math.min(spherePos.z, max.z));
      const closest = new BABYLON.Vector3(cx, cy, cz);
      const dist = spherePos.subtract(closest);
      const sq = dist.lengthSquared();
      if (sq > radius * radius) return null;
      const topY = max.y;
      if (spherePos.y >= topY && (spherePos.y - radius) <= topY + 0.35) {
        return { type:"top", y: topY };
      }
      return { type:"side" };
    }

    // Input
    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (k === "w" || k === "arrowup") keys.w = true;
      if (k === "s" || k === "arrowdown") keys.s = true;
      if (k === "a" || k === "arrowleft") keys.a = true;
      if (k === "d" || k === "arrowright") keys.d = true;
      if (k === " ") { keys.space = true; tryJump(); }
    });
    window.addEventListener("keyup", (e) => {
      const k = e.key.toLowerCase();
      if (k === "w" || k === "arrowup") keys.w = false;
      if (k === "s" || k === "arrowdown") keys.s = false;
      if (k === "a" || k === "arrowleft") keys.a = false;
      if (k === "d" || k === "arrowright") keys.d = false;
      if (k === " ") keys.space = false;
    });

    // Joystick
    const joyEl = document.getElementById("joystick");
    const stickEl = document.getElementById("joyStick");
    let joyCenter = null;
    function setStick(dx, dy){ stickEl.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`; }
    function joyTouch(e) {
      const rect = joyEl.getBoundingClientRect();
      if (!joyCenter) joyCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
      const t = e.changedTouches ? e.changedTouches[0] : e;
      const dx = t.clientX - joyCenter.x;
      const dy = t.clientY - joyCenter.y;
      const len = Math.hypot(dx, dy);
      const clamp = Math.min(len, joy.max);
      const nx = len > 0 ? dx * clamp / len : 0;
      const ny = len > 0 ? dy * clamp / len : 0;
      joy.dx = nx; joy.dy = ny; joy.active = true; setStick(nx, ny);
    }
    function joyEnd(){ joy.active=false; joy.dx=0; joy.dy=0; setStick(0,0); }
    joyEl.addEventListener("touchstart", (e)=>{ e.preventDefault(); joyTouch(e); }, { passive:false });
    joyEl.addEventListener("touchmove", (e)=>{ e.preventDefault(); joyTouch(e); }, { passive:false });
    joyEl.addEventListener("touchend", (e)=>{ e.preventDefault(); joyEnd(); }, { passive:false });
    joyEl.addEventListener("touchcancel", (e)=>{ e.preventDefault(); joyEnd(); }, { passive:false });

    // Buttons
    document.getElementById("jumpBtn").addEventListener("touchstart", (e)=>{ e.preventDefault(); tryJump(); }, { passive:false });
    document.getElementById("jumpBtn").addEventListener("click", tryJump);
    document.getElementById("restartBtn").addEventListener("click", ()=>resetPlayer(true));
    document.getElementById("switchMenuBtn").addEventListener("click", ()=>showMenu(true));

    // Level picker
    document.querySelectorAll(".levelBtn").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        currentLevel = btn.dataset.level;
        showMenu(false);
        buildLevel(currentLevel);
      });
    });

    function showMenu(show) {
      document.getElementById("levelMenu").style.display = show ? "flex" : "none";
      if (show) document.getElementById("winBanner").style.display = "none";
    }

    function tryJump() {
      // Allow jump if grounded or if we still have jumps left (double jump)
      if (playerState.grounded || playerState.jumpsUsed < playerState.maxJumps) {
        playerState.vel.y = playerState.jumpPower;
        playerState.grounded = false;
        playerState.jumpsUsed += 1;
      }
    }

    function resetPlayer(resetTimer=false) {
      won = false;
      document.getElementById("winBanner").style.display = "none";
      playerState.pos.copyFrom(new BABYLON.Vector3(0, 2, 0));
      playerState.vel.copyFrom(new BABYLON.Vector3(0, 0, 0));
      playerState.grounded = false;
      playerState.jumpsUsed = 0;
      player.position.copyFrom(playerState.pos);
      if (resetTimer) startTime = performance.now();
    }

    function getMoveInputVector() {
      let mz = 0, mx = 0;
      if (keys.w) mz += 1;
      if (keys.s) mz -= 1;
      if (keys.a) mx -= 1;
      if (keys.d) mx += 1;
      let jx = 0, jz = 0;
      if (joy.active) {
        const nx = joy.dx / joy.max;
        const ny = joy.dy / joy.max;
        jx = nx; jz = -ny;
      }
      const x = mx + jx, z = mz + jz;
      const len = Math.hypot(x, z);
      return len > 0 ? new BABYLON.Vector3(x/len, 0, z/len) : BABYLON.Vector3.Zero();
    }

    function update(delta) {
      if (won) return;
      const t = (performance.now() - startTime) / 1000;
      document.getElementById("timer").textContent = t.toFixed(1);

      // Animate moving platforms
      movingPlatforms.forEach(mp => {
        mp.phase += delta * mp.speed;
        const offset = Math.sin(mp.phase) * mp.amp;
        if (mp.axis === "x") mp.mesh.position.x = offset;
        else if (mp.axis === "z") mp.mesh.position.z = offset;
      });

      // Rotate bars
      rotatingBars.forEach(rb => rb.mesh.rotation.y += delta * rb.speed);

      // Movement
      const dir = getMoveInputVector();
      playerState.vel.x = dir.x * playerState.speed;
      playerState.vel.z = dir.z * playerState.speed;

      // Gravity
      playerState.vel.y += playerState.gravity * delta;
      if (playerState.vel.y < -40) playerState.vel.y = -40;

      // Integrate
      const nextPos = playerState.pos.add(playerState.vel.scale(delta));

      // Pit detection
      if (nextPos.y < -20) { resetPlayer(true); return; }

      // Collisions: platforms support
      playerState.grounded = false;
      let resolvedTopY = null;
      const allPlatforms = levelPlatforms.concat(movingPlatforms.map(mp => mp.mesh));
      for (let i = 0; i < allPlatforms.length; i++) {
        const plat = allPlatforms[i];
        const res = sphereVsAABB_YSupport(nextPos, playerState.radius, plat);
        if (!res) continue;
        if (res.type === "top" && playerState.vel.y <= 0) {
          resolvedTopY = (resolvedTopY === null) ? res.y : Math.max(resolvedTopY, r
