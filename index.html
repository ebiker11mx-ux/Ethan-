<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Obstacle Course (Mobile-Friendly)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <style>
    html, body {
      width: 100%; height: 100%; margin: 0; overflow: hidden; background: #0b0f1a;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    #renderCanvas {
      width: 100%; height: 100%; touch-action: none; display: block;
    }
    /* UI overlay */
    .hud {
      position: fixed; inset: 0; pointer-events: none;
    }
    .button {
      position: absolute; pointer-events: auto; border: none; outline: none;
      color: white; font-weight: 700; border-radius: 14px;
      background: linear-gradient(135deg, #1e88e5, #6a1b9a);
      box-shadow: 0 6px 16px rgba(0,0,0,0.4);
    }
    #restartBtn {
      top: 16px; left: 16px; padding: 10px 14px; font-size: 14px;
    }
    #jumpBtn {
      bottom: 28px; right: 24px; width: 74px; height: 74px; font-size: 14px;
      border-radius: 50%;
    }
    /* Virtual joystick */
    #joystick {
      position: absolute; bottom: 22px; left: 22px; width: 140px; height: 140px;
      pointer-events: auto;
    }
    .joy-bg {
      position: absolute; width: 100%; height: 100%;
      border-radius: 50%; background: rgba(255,255,255,0.08);
      border: 2px solid rgba(255,255,255,0.15);
      box-shadow: inset 0 0 30px rgba(255,255,255,0.04);
    }
    .joy-stick {
      position: absolute; left: 50%; top: 50%; width: 70px; height: 70px;
      transform: translate(-50%, -50%);
      border-radius: 50%; background: rgba(255,255,255,0.18);
      border: 2px solid rgba(255,255,255,0.3);
      box-shadow: 0 10px 18px rgba(0,0,0,0.35);
    }
    /* Win banner */
    #winBanner {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.7); color: #fff; padding: 18px 22px; border-radius: 12px;
      font-size: 18px; letter-spacing: 0.3px; display: none; pointer-events: auto;
      box-shadow: 0 10px 24px rgba(0,0,0,0.45);
    }
    /* FPS/timer */
    #info {
      position: absolute; top: 16px; right: 16px; color: #bfe9ff; font-size: 12px;
      background: rgba(0,0,0,0.35); padding: 8px 10px; border-radius: 10px;
      box-shadow: 0 6px 16px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <div class="hud">
    <button id="restartBtn" class="button">Restart</button>
    <button id="jumpBtn" class="button">Jump</button>

    <div id="joystick">
      <div class="joy-bg"></div>
      <div class="joy-stick" id="joyStick"></div>
    </div>

    <div id="winBanner">You win! Time: <span id="winTime">0.0</span>s<br/><small>Tap Restart to play again</small></div>
    <div id="info">Time: <span id="timer">0.0</span>s</div>
  </div>

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

    // Core variables
    let scene, player, followCam;
    let levelPlatforms = [];
    let movingPlatforms = [];
    let rotatingBars = [];
    let goalTrigger;
    let startTime = 0;
    let won = false;

    // Player state
    const playerState = {
      radius: 0.5,
      pos: new BABYLON.Vector3(0, 2, 0),
      vel: new BABYLON.Vector3(0, 0, 0),
      speed: 7.5,
      jumpPower: 10.5,
      gravity: -22.0,
      grounded: false
    };

    // Input
    const keys = { w:false, a:false, s:false, d:false, space:false };
    const joy = { active:false, dx:0, dy:0, max:55 };

    function createScene() {
      scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0.03, 0.05, 0.1, 1.0);

      // Lights
      const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
      hemi.intensity = 0.85;
      const dir = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-0.4, -0.9, -0.2), scene);
      dir.intensity = 0.5;

      // Skybox (simple gradient-like material)
      const sky = BABYLON.MeshBuilder.CreateBox("sky", { size: 2000 }, scene);
      const skyMat = new BABYLON.StandardMaterial("skyMat", scene);
      skyMat.backFaceCulling = false;
      skyMat.diffuseColor = new BABYLON.Color3(0.02, 0.04, 0.09);
      skyMat.emissiveColor = new BABYLON.Color3(0.02, 0.04, 0.09);
      sky.material = skyMat;

      // Player
      player = BABYLON.MeshBuilder.CreateSphere("player", { diameter: playerState.radius * 2 }, scene);
      const pMat = new BABYLON.StandardMaterial("pMat", scene);
      pMat.diffuseColor = new BABYLON.Color3(0.2, 0.8, 1.0);
      pMat.emissiveColor = new BABYLON.Color3(0.05, 0.25, 0.35);
      player.material = pMat;
      player.position.copyFrom(playerState.pos);

      // Camera follows player
      followCam = new BABYLON.FollowCamera("followCam", player.position.add(new BABYLON.Vector3(0, 6, -10)), scene);
      followCam.radius = 12;
      followCam.heightOffset = 4.5;
      followCam.rotationOffset = 0;
      followCam.cameraAcceleration = 0.06;
      followCam.maxCameraSpeed = 50;
      followCam.lockedTarget = player;
      followCam.attachControl(canvas, true);

      buildLevel();

      return scene;
    }

    function buildLevel() {
      // Ground start
      const startGround = makePlatform(new BABYLON.Vector3(0, 0, 0), 14, 14, "#2b4b7a");
      levelPlatforms.push(startGround);

      // Path of platforms forward along +Z
      let z = 10;
      const colors = ["#3569a4", "#3f82b8", "#4e97c9", "#57a6d4", "#6bbbe6"];
      for (let i = 0; i < 6; i++) {
        levelPlatforms.push(makePlatform(new BABYLON.Vector3(0, 0.5, z), 6, 6, colors[i % colors.length]));
        z += 10;
      }

      // Moving platform (oscillates on X)
      const mp = makePlatform(new BABYLON.Vector3(0, 1.2, z), 6, 6, "#e6a86b");
      movingPlatforms.push({ mesh: mp, amp: 5, speed: 1.2, phase: 0, axis: "x" });
      z += 12;

      // Rotating bar obstacle
      const barBase = makePlatform(new BABYLON.Vector3(0, 0.5, z), 8, 8, "#7a2b58");
      levelPlatforms.push(barBase);
      const bar = BABYLON.MeshBuilder.CreateBox("rotBar", { width: 1.0, height: 0.6, depth: 12 }, scene);
      bar.position = new BABYLON.Vector3(0, 1.6, z);
      const barMat = new BABYLON.StandardMaterial("barMat", scene);
      barMat.diffuseColor = new BABYLON.Color3(0.95, 0.35, 0.65);
      bar.material = barMat;
      rotatingBars.push({ mesh: bar, speed: 1.3 });

      z += 14;

      // Small stepping stones
      for (let i = 0; i < 7; i++) {
        const x = (i % 2 === 0) ? -2.5 : 2.5;
        levelPlatforms.push(makePlatform(new BABYLON.Vector3(x, 1.0, z), 3.2, 3.2, "#3aa884"));
        z += 6;
      }

      // Final platform and goal
      const finalPlat = makePlatform(new BABYLON.Vector3(0, 1.0, z), 10, 10, "#2e8f5d");
      levelPlatforms.push(finalPlat);

      goalTrigger = BABYLON.MeshBuilder.CreateBox("goal", { width: 6, height: 2, depth: 6 }, scene);
      goalTrigger.position = new BABYLON.Vector3(0, 2.0, z);
      const goalMat = new BABYLON.StandardMaterial("goalMat", scene);
      goalMat.diffuseColor = new BABYLON.Color3(1.0, 0.85, 0.2);
      goalMat.alpha = 0.6;
      goalTrigger.material = goalMat;
    }

    function makePlatform(pos, w, d, colorHex = "#3569a4") {
      const plat = BABYLON.MeshBuilder.CreateBox("plat", { width: w, height: 0.8, depth: d }, scene);
      plat.position = pos.clone();
      const mat = new BABYLON.StandardMaterial("platMat", scene);
      const c = hexToColor3(colorHex);
      mat.diffuseColor = c.clone();
      mat.specularColor = new BABYLON.Color3(0.12, 0.12, 0.12);
      plat.material = mat;

      // Slight emissive to pop visually
      mat.emissiveColor = c.scale(0.1);
      return plat;
    }

    function hexToColor3(hex) {
      const h = hex.replace("#", "");
      const r = parseInt(h.substring(0, 2), 16) / 255;
      const g = parseInt(h.substring(2, 4), 16) / 255;
      const b = parseInt(h.substring(4, 6), 16) / 255;
      return new BABYLON.Color3(r, g, b);
    }

    // Simple AABB collision test between player sphere and platform box; returns penetration normal if intersecting on Y
    function sphereVsAABB_YSupport(spherePos, radius, box) {
      const b = box.getBoundingInfo().boundingBox;
      const min = b.minimumWorld, max = b.maximumWorld;
      // Closest point clamp
      const cx = Math.max(min.x, Math.min(spherePos.x, max.x));
      const cy = Math.max(min.y, Math.min(spherePos.y, max.y));
      const cz = Math.max(min.z, Math.min(spherePos.z, max.z));
      const closest = new BABYLON.Vector3(cx, cy, cz);

      const dist = spherePos.subtract(closest);
      const sq = dist.lengthSquared();
      if (sq > radius * radius) return null;

      // Prefer resolving vertical support if sphere is above top face
      // If sphere center is above top, lift to top
      const topY = max.y;
      if (spherePos.y >= topY && (spherePos.y - radius) <= topY + 0.3) {
        return { type: "top", y: topY };
      }
      return { type: "side" };
    }

    // Input setup
    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (k === "w" || k === "arrowup") keys.w = true;
      if (k === "s" || k === "arrowdown") keys.s = true;
      if (k === "a" || k === "arrowleft") keys.a = true;
      if (k === "d" || k === "arrowright") keys.d = true;
      if (k === " "){ keys.space = true; tryJump(); }
    });
    window.addEventListener("keyup", (e) => {
      const k = e.key.toLowerCase();
      if (k === "w" || k === "arrowup") keys.w = false;
      if (k === "s" || k === "arrowdown") keys.s = false;
      if (k === "a" || k === "arrowleft") keys.a = false;
      if (k === "d" || k === "arrowright") keys.d = false;
      if (k === " ") keys.space = false;
    });

    // Virtual joystick
    const joyEl = document.getElementById("joystick");
    const stickEl = document.getElementById("joyStick");
    let joyCenter = null;

    function setStick(dx, dy) {
      stickEl.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
    }

    function joyTouch(e) {
      const rect = joyEl.getBoundingClientRect();
      if (!joyCenter) joyCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
      const t = e.changedTouches ? e.changedTouches[0] : e;
      const dx = t.clientX - joyCenter.x;
      const dy = t.clientY - joyCenter.y;
      const len = Math.hypot(dx, dy);
      const clamp = Math.min(len, joy.max);
      const nx = len > 0 ? dx * clamp / len : 0;
      const ny = len > 0 ? dy * clamp / len : 0;
      joy.dx = nx; joy.dy = ny; joy.active = true;
      setStick(nx, ny);
    }
    function joyEnd() {
      joy.active = false; joy.dx = 0; joy.dy = 0; setStick(0,0);
    }
    joyEl.addEventListener("touchstart", (e)=>{ e.preventDefault(); joyTouch(e); }, { passive: false });
    joyEl.addEventListener("touchmove", (e)=>{ e.preventDefault(); joyTouch(e); }, { passive: false });
    joyEl.addEventListener("touchend", (e)=>{ e.preventDefault(); joyEnd(); }, { passive: false });
    joyEl.addEventListener("touchcancel", (e)=>{ e.preventDefault(); joyEnd(); }, { passive: false });

    // Jump button
    document.getElementById("jumpBtn").addEventListener("touchstart", (e)=>{ e.preventDefault(); tryJump(); }, { passive: false });
    document.getElementById("jumpBtn").addEventListener("click", tryJump);

    // Restart
    document.getElementById("restartBtn").addEventListener("click", restart);
    function restart() {
      won = false;
      document.getElementById("winBanner").style.display = "none";
      playerState.pos.copyFrom(new BABYLON.Vector3(0, 2, 0));
      playerState.vel.copyFrom(new BABYLON.Vector3(0, 0, 0));
      playerState.grounded = false;
      startTime = performance.now();
    }

    function tryJump() {
      if (playerState.grounded) {
        playerState.vel.y = playerState.jumpPower;
        playerState.grounded = false;
      }
    }

    function getMoveInputVector() {
      // Keyboard input
      let mz = 0, mx = 0;
      if (keys.w) mz += 1;
      if (keys.s) mz -= 1;
      if (keys.a) mx -= 1;
      if (keys.d) mx += 1;

      // Joystick input (convert screen dx,dy to world forward/right relative to camera yaw)
      let jx = 0, jz = 0;
      if (joy.active) {
        const nx = joy.dx / joy.max;  // -1 .. 1
        const ny = joy.dy / joy.max;  // -1 .. 1 (down positive)
        // Map joystick: up = forward (+z), left = -x
        jx = nx;
        jz = -ny;
      }

      const x = mx + jx;
      const z = mz + jz;

      // Normalize
      const len = Math.hypot(x, z);
      if (len > 0) {
        return new BABYLON.Vector3(x/len, 0, z/len);
      }
      return BABYLON.Vector3.Zero();
    }

    function update(delta) {
      if (won) return;

      // Timer
      const t = (performance.now() - startTime) / 1000;
      document.getElementById("timer").textContent = t.toFixed(1);

      // Animate moving platforms
      movingPlatforms.forEach(mp => {
        mp.phase += delta * mp.speed;
        const offset = Math.sin(mp.phase) * mp.amp;
        if (mp.axis === "x") mp.mesh.position.x = offset;
        else if (mp.axis === "z") mp.mesh.position.z = offset;
      });

      // Rotate bars
      rotatingBars.forEach(rb => {
        rb.mesh.rotation.y += delta * rb.speed;
      });

      // Movement input
      const dir = getMoveInputVector();
      playerState.vel.x = dir.x * playerState.speed;
      playerState.vel.z = dir.z * playerState.speed;

      // Gravity
      playerState.vel.y += playerState.gravity * delta;
      if (playerState.vel.y < -40) playerState.vel.y = -40;

      // Integrate position
      const nextPos = playerState.pos.add(playerState.vel.scale(delta));

      // Basic floor death: if fall below threshold, restart to last safe ground
      if (nextPos.y < -20) {
        restart();
        return;
      }

      // Collision with platforms (support on top surface)
      playerState.grounded = false;
      let resolvedTopY = null;

      // Check all static and moving platforms
      const allPlatforms = levelPlatforms.concat(movingPlatforms.map(mp => mp.mesh));
      for (let i = 0; i < allPlatforms.length; i++) {
        const plat = allPlatforms[i];
        const res = sphereVsAABB_YSupport(nextPos, playerState.radius, plat);
        if (!res) continue;
        if (res.type === "top") {
          resolvedTopY = (resolvedTopY === null) ? res.y : Math.max(resolvedTopY, res.y);
        }
      }

      // Resolve vertical support
      if (resolvedTopY !== null && playerState.vel.y <= 0) {
        nextPos.y = resolvedTopY + playerState.radius;
        playerState.vel.y = 0;
        playerState.grounded = true;
      }

      // Simple hit with rotating bars: knock back
      rotatingBars.forEach(rb => {
        if (player.intersectsMesh(rb.mesh, false)) {
          // Push away and small stun
          const push = playerState.pos.subtract(rb.mesh.position);
          push.y = 0;
          const len = push.length();
          if (len < 0.001) push.copyFromFloats(Math.random()*2-1, 0, Math.random()*2-1);
          push.normalize();
          playerState.vel.x = push.x * 8;
          playerState.vel.z = push.z * 8;
          playerState.vel.y = 6;
          playerState.grounded = false;
        }
      });

      // Apply final position
      playerState.pos.copyFrom(nextPos);
      player.position.copyFrom(playerState.pos);

      // Win check
      if (player.intersectsMesh(goalTrigger, false)) {
        won = true;
        const winTime = ((performance.now() - startTime) / 1000).toFixed(1);
        document.getElementById("winTime").textContent = winTime;
        document.getElementById("winBanner").style.display = "block";
      }
    }

    // Init
    const sceneInstance = createScene();
    startTime = performance.now();

    engine.runRenderLoop(() => {
      const delta = scene.getEngine().getDeltaTime() / 1000;
      update(delta);
      scene.render();
    });

    window.addEventListener("resize", () => engine.resize());
  </script>
</body>
</html>
