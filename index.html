<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Babylon Obby â€” Simple & Reliable</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; background:#0b0d12; font-family:system-ui, Arial, sans-serif; }
    #renderCanvas { width:100vw; height:100vh; display:block; }
    #hud {
      position:fixed; top:10px; left:10px; color:#eaf2ff; z-index:10;
      background:rgba(0,0,0,0.35); padding:10px 12px; border-radius:8px; backdrop-filter: blur(4px);
      display:flex; gap:12px; align-items:center; font-size:14px;
    }
    #hud .pill { background:rgba(255,255,255,0.1); padding:6px 8px; border-radius:999px; }
    #center {
      position:fixed; top:50%; left:50%; transform:translate(-50%, -50%);
      background:rgba(0,0,0,0.5); color:#c9d7ff; padding:16px 18px; border-radius:10px; text-align:center; z-index:10;
    }
    #center button { margin-top:10px; padding:8px 14px; border-radius:8px; border:none; cursor:pointer; font-weight:600; background:#5a84ff; color:#fff; }
    #resetBtn { position:fixed; top:10px; right:10px; z-index:10; padding:8px 12px; border:none; border-radius:8px; background:#ff6f6f; color:#fff; }
  </style>
</head>
<body>
  <div id="hud">
    <div class="pill">Level: <span id="levelLabel">1</span></div>
    <div class="pill">Time: <span id="timeLabel">0.0s</span></div>
    <div class="pill">Deaths: <span id="deathsLabel">0</span></div>
    <div class="pill">Coins: <span id="coinsLabel">0</span></div>
  </div>
  <button id="resetBtn">Reset</button>

  <div id="center">
    <div style="font-weight:700; font-size:18px; margin-bottom:6px;">Babylon 3D Obby</div>
    <div>WASD/Arrows to move, Space to jump. Reach the glowing goal.</div>
    <button id="playBtn">Play</button>
  </div>

  <canvas id="renderCanvas"></canvas>

  <!-- Babylon.js CDN -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>

  <script>
  (function(){
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

    const hud = {
      levelLabel: document.getElementById('levelLabel'),
      timeLabel: document.getElementById('timeLabel'),
      deathsLabel: document.getElementById('deathsLabel'),
      coinsLabel: document.getElementById('coinsLabel')
    };
    const center = document.getElementById('center');
    const playBtn = document.getElementById('playBtn');
    const resetBtn = document.getElementById('resetBtn');

    let scene, camera;
    let player, playerCollider;
    let keys = { f:false,b:false,l:false,r:false,j:false };
    let vel = new BABYLON.Vector3(0,0,0);
    let gravity = 14;
    let moveSpeed = 6.2;
    let jumpSpeed = 6.2;
    let grounded = false;

    let levelIndex = 0;
    let deaths = 0;
    let coinsCollected = 0;
    let startTime = performance.now();

    let solids = [];      // collidable meshes
    let movers = [];      // moving platforms
    let hazards = [];     // hazards (lava)
    let goalMesh = null;
    let coins = [];

    function updateHUD() {
      hud.levelLabel.textContent = (levelIndex + 1);
      hud.deathsLabel.textContent = deaths;
      hud.coinsLabel.textContent = coinsCollected;
      const t = (performance.now() - startTime) / 1000;
      hud.timeLabel.textContent = t.toFixed(1) + 's';
    }

    function makeScene(){
      scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0.043, 0.051, 0.071, 1);

      // Camera: follow style without pointer lock
      camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0, 2.2, -6), scene);
      camera.setTarget(BABYLON.Vector3.Zero());
      camera.inputs.clear();
      camera.attachControl(canvas, true);

      // Lights
      const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);
      hemi.intensity = 0.85;
      const dir = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-0.6,-1,-0.2), scene);
      dir.intensity = 0.7;

      // Ground and grid
      const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 80, height: 80}, scene);
      ground.position.y = 0;
      const gMat = new BABYLON.StandardMaterial("gMat", scene);
      gMat.diffuseColor = new BABYLON.Color3(0.11,0.14,0.20);
      ground.material = gMat;
      ground.checkCollisions = true;
      solids.push(ground);

      // Player (visual + collider box)
      player = BABYLON.MeshBuilder.CreateBox("player", { width: 0.6, height: 1.2, depth: 0.6 }, scene);
      const pMat = new BABYLON.StandardMaterial("pMat", scene);
      pMat.diffuseColor = new BABYLON.Color3(0.92,0.95,1.0);
      player.material = pMat;
      player.position = new BABYLON.Vector3(-10, 1.2/2 + 0.02, 0);

      playerCollider = player; // using same mesh as collider for simplicity

      // Obstacles for level 1
      function addPlatform(x,y,z,w=3,h=0.4,d=3,color=new BABYLON.Color3(0.35,0.52,1.0)) {
        const m = BABYLON.MeshBuilder.CreateBox("plat", {width:w, height:h, depth:d}, scene);
        const mat = new BABYLON.StandardMaterial("platMat", scene);
        mat.diffuseColor = color;
        m.material = mat;
        m.position.set(x,y,z);
        m.checkCollisions = true;
        solids.push(m);
        return m;
      }
      function addHazard(x,y,z,w=10,h=0.2,d=10) {
        const m = BABYLON.MeshBuilder.CreateBox("haz", {width:w,height:h,depth:d}, scene);
        const mat = new BABYLON.StandardMaterial("hazMat", scene);
        mat.diffuseColor = new BABYLON.Color3(1.0,0.35,0.35);
        mat.emissiveColor = new BABYLON.Color3(0.3,0,0);
        m.material = mat;
        m.position.set(x,y,z);
        hazards.push(m);
        return m;
      }
      function addGoal(x,y,z) {
        const m = BABYLON.MeshBuilder.CreateCylinder("goal", {diameter:2, height:0.5}, scene);
        const mat = new BABYLON.StandardMaterial("goalMat", scene);
        mat.diffuseColor = new BABYLON.Color3(0.35,0.83,0.54);
        mat.emissiveColor = new BABYLON.Color3(0.1,0.4,0.2);
        m.material = mat;
        m.position.set(x,y,z);
        goalMesh = m;
        return m;
      }
      function addCoin(x,y,z) {
        const m = BABYLON.MeshBuilder.CreateCylinder("coin", {diameter:0.8, height:0.12, tessellation:30}, scene);
        const mat = new BABYLON.StandardMaterial("coinMat", scene);
        mat.diffuseColor = new BABYLON.Color3(1.0,0.84,0.0);
        mat.specularColor = new BABYLON.Color3(1,1,1);
        m.material = mat;
        m.rotation.x = Math.PI/2;
        m.position.set(x,y,z);
        coins.push(m);
        return m;
      }

      // Level layout
      // Static path
      for (let i = 0; i < 6; i++) addPlatform(-6 + i*3, 0.2, 0);
      addPlatform(4.5, 0.2, 0); // final

      // Moving platform (back & forth)
      const mover = addPlatform(6, 0.5, 0, 3,0.4,3,new BABYLON.Color3(0.4,0.7,1.0));
      movers.push({ mesh: mover, axis: 'z', min: -3, max: 3, speed: 1.4, v: 1.4 });

      // Hazard pit
      addHazard(2, -0.4, 0);

      // Coins
      addCoin(-6, 1.1, 0);
      addCoin(3, 1.1, 0);

      // Goal
      addGoal(10, 0.25, 0);

      // Controls
      window.addEventListener('keydown', (e)=>{
        if (e.code === 'KeyW' || e.code === 'ArrowUp') keys.f = true;
        if (e.code === 'KeyS' || e.code === 'ArrowDown') keys.b = true;
        if (e.code === 'KeyA' || e.code === 'ArrowLeft') keys.l = true;
        if (e.code === 'KeyD' || e.code === 'ArrowRight') keys.r = true;
        if (e.code === 'Space') keys.j = true;
      });
      window.addEventListener('keyup', (e)=>{
        if (e.code === 'KeyW' || e.code === 'ArrowUp') keys.f = false;
        if (e.code === 'KeyS' || e.code === 'ArrowDown') keys.b = false;
        if (e.code === 'KeyA' || e.code === 'ArrowLeft') keys.l = false;
        if (e.code === 'KeyD' || e.code === 'ArrowRight') keys.r = false;
        if (e.code === 'Space') keys.j = false;
      });
    }

    function resetGame() {
      // Clear scene arrays and rebuild
      solids = []; movers = []; hazards = []; coins = []; goalMesh = null;
      vel.set(0,0,0);
      grounded = false;
      makeScene();
      player.position = new BABYLON.Vector3(-10, 1.2/2 + 0.02, 0);
      updateHUD();
    }

    function updateMovers(dt) {
      for (const m of movers) {
        const axis = m.axis;
        m.mesh.position[axis] += m.v * dt;
        if (m.mesh.position[axis] < m.min) { m.mesh.position[axis] = m.min; m.v = Math.abs(m.speed); }
        if (m.mesh.position[axis] > m.max) { m.mesh.position[axis] = m.max; m.v = -Math.abs(m.speed); }
      }
    }

    function checkOverlap(a, b) {
      // AABB overlap using bounding boxes
      const ba = a.getBoundingInfo().boundingBox;
      const bb = b.getBoundingInfo().boundingBox;
      return (
        ba.maximumWorld.x >= bb.minimumWorld.x &&
        ba.minimumWorld.x <= bb.maximumWorld.x &&
        ba.maximumWorld.y >= bb.minimumWorld.y &&
        ba.minimumWorld.y <= bb.maximumWorld.y &&
        ba.maximumWorld.z >= bb.minimumWorld.z &&
        ba.minimumWorld.z <= bb.maximumWorld.z
      );
    }

    function gameStep(dt) {
      // Input movement in camera space (XZ only)
      const forward = new BABYLON.Vector3(0,0,1);
      const right = new BABYLON.Vector3(1,0,0);
      let move = new BABYLON.Vector3(0,0,0);
      if (keys.f) move.addInPlace(forward);
      if (keys.b) move.subtractInPlace(forward);
      if (keys.l) move.subtractInPlace(right);
      if (keys.r) move.addInPlace(right);
      if (move.lengthSquared() > 0) move.normalize();

      vel.x = move.x * moveSpeed;
      vel.z = move.z * moveSpeed;

      // Jump + gravity
      if (keys.j && grounded) {
        vel.y = jumpSpeed;
        grounded = false;
      }
      vel.y -= gravity * dt;
      // Integrate
      player.position.addInPlace(new BABYLON.Vector3(vel.x*dt, vel.y*dt, vel.z*dt));

      // Ground plane collision
      if (player.position.y < 1.2/2) {
        player.position.y = 1.2/2;
        vel.y = 0;
        grounded = true;
      }

      // Collide with solids (simple push-out using bounding boxes)
      for (const s of solids) {
        if (s === player) continue;
        if (checkOverlap(player, s)) {
          // compute minimal axis separation
          const pa = player.getBoundingInfo().boundingBox;
          const pb = s.getBoundingInfo().boundingBox;
          const dx1 = pb.maximumWorld.x - pa.minimumWorld.x;
          const dx2 = pa.maximumWorld.x - pb.minimumWorld.x;
          const dz1 = pb.maximumWorld.z - pa.minimumWorld.z;
          const dz2 = pa.maximumWorld.z - pb.minimumWorld.z;
          const dy1 = pb.maximumWorld.y - pa.minimumWorld.y;
          const dy2 = pa.maximumWorld.y - pb.minimumWorld.y;

          const overlaps = [
            {axis:'x', val: Math.min(dx1, dx2)},
            {axis:'z', val: Math.min(dz1, dz2)},
            {axis:'y', val: Math.min(dy1, dy2)},
          ].sort((a,b)=>a.val-b.val);

          const smallest = overlaps[0];
          if (smallest.axis === 'y') {
            // push up or down
            const pushUp = dy1 < dy2;
            player.position.y += (pushUp ? -dy1 : dy2);
            if (pushUp) { vel.y = Math.max(vel.y, 0); } else { vel.y = Math.min(vel.y, 0); grounded = true; }
          } else if (smallest.axis === 'x') {
            const pushLeft = dx1 < dx2;
            player.position.x += (pushLeft ? -dx1 : dx2);
            vel.x = 0;
          } else {
            const pushBack = dz1 < dz2;
            player.position.z += (pushBack ? -dz1 : dz2);
            vel.z = 0;
          }
        }
      }

      // Hazard check
      for (const h of hazards) {
        if (checkOverlap(player, h)) {
          deaths++;
          player.position = new BABYLON.Vector3(-10, 1.2/2 + 0.02, 0);
          vel.set(0,0,0);
          grounded = false;
          updateHUD();
          break;
        }
      }

      // Goal check
      if (goalMesh && checkOverlap(player, goalMesh)) {
        center.style.display = 'block';
        center.innerHTML = '<div style="font-weight:700; font-size:18px; margin-bottom:6px;">Level complete!</div>' +
          '<div>Deaths: '+deaths+' | Coins: '+coinsCollected+' | Time: '+hud.timeLabel.textContent+'</div>' +
          '<button id="againBtn" style="margin-top:10px;padding:8px 14px;border-radius:8px;border:none;cursor:pointer;background:#5a84ff;color:#fff;">Play again</button>';
        const againBtn = document.getElementById('againBtn');
        againBtn.addEventListener('click', ()=>{
          center.style.display = 'none';
          // Reset stats except total coins
          deaths = 0; startTime = performance.now();
          resetGame();
        });
      }

      // Coins: collect + spin
      for (let i = coins.length - 1; i >= 0; i--) {
        const c = coins[i];
        c.rotation.y += 2.5 * dt;
        if (checkOverlap(player, c)) {
          coinsCollected++;
          c.dispose();
          coins.splice(i, 1);
          updateHUD();
        }
      }

      // Camera follow
      const target = player.position.clone();
      camera.position = target.add(new BABYLON.Vector3(0, 2.2, -6));
      camera.setTarget(target);
    }

    resetBtn.addEventListener('click', ()=>{
      deaths = 0; coinsCollected = 0; startTime = performance.now();
      center.style.display = 'none';
      resetGame();
    });

    playBtn.addEventListener('click', ()=>{
      center.style.display = 'none';
      deaths = 0; coinsCollected = 0; startTime = performance.now();
      resetGame();
    });

    makeScene();
    updateHUD();

    engine.runRenderLoop(function() {
      const now = performance.now();
      const dt = Math.min(0.033, engine.getDeltaTime() / 1000);
      updateMovers(dt);
      gameStep(dt);
      updateHUD();
      scene.render();
    });

    window.addEventListener("resize", function () { engine.resize(); });
  })();
  </script>
</body>
</html>
