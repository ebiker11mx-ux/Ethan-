<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Obby — 5 Levels</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #0b0f1a;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Arial, sans-serif;
      color: #e6e6e6;
      overflow: hidden;
    }
    #ui {
      position: fixed;
      top: 12px; left: 12px; right: 12px;
      display: flex; justify-content: space-between; align-items: center;
      pointer-events: none;
    }
    .panel {
      backdrop-filter: blur(6px);
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px;
      padding: 10px 14px;
      pointer-events: auto;
    }
    #instructions {
      max-width: 520px;
      line-height: 1.4;
    }
    #stats {
      display: flex; gap: 10px; align-items: center;
      font-weight: 600;
    }
    #btnStart {
      cursor: pointer;
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.25);
      background: linear-gradient(180deg, #27ae60, #1e874b);
      color: white;
      font-weight: 700;
    }
    #btnStart:active { transform: translateY(1px); }
    #overlay {
      position: fixed; inset: 0; display: grid; place-items: center;
      background: rgba(0,0,0,0.65); z-index: 100; opacity: 0; pointer-events: none;
      transition: opacity .2s ease;
    }
    #overlay.show { opacity: 1; pointer-events: auto; }
    #message {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 16px 20px; max-width: 420px; text-align: center;
    }
    #message h2 { margin: 0 0 8px 0; }
    #message p { margin: 0 0 12px 0; }
    #message button {
      cursor: pointer;
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.25);
      background: linear-gradient(180deg, #2d9cdb, #2479a8);
      color: white;
      font-weight: 700;
    }
    /* Crosshair */
    #crosshair {
      position: fixed; left: 50%; top: 50%;
      width: 18px; height: 18px; transform: translate(-50%, -50%);
      display: grid; place-items: center; pointer-events: none;
    }
    #crosshair::before {
      content: "";
      width: 2px; height: 18px; background: rgba(255,255,255,0.7); border-radius: 1px;
    }
    #crosshair::after {
      content: "";
      position: absolute; width: 18px; height: 2px; background: rgba(255,255,255,0.7); border-radius: 1px;
    }
    /* Mobile hint */
    #mobileHint {
      position: fixed; bottom: 12px; left: 12px; right: 12px;
      text-align: center;
      opacity: 0.85;
    }

    /* Simple on-screen controls (optional) */
    #touchControls {
      position: fixed; bottom: 24px; left: 24px; right: 24px;
      display: none; justify-content: space-between; align-items: center;
    }
    .stick, .jump {
      width: 96px; height: 96px;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      backdrop-filter: blur(6px);
      touch-action: none;
      user-select: none;
    }
    .jump { width: 84px; height: 84px; }
    @media (max-width: 900px) {
      #touchControls { display: flex; }
      #instructions { display: none; }
      #crosshair { display: none; }
    }
  </style>
</head>
<body>
  <div id="ui">
    <div id="instructions" class="panel">
      <strong>Controls:</strong> WASD to move, Space to jump, Mouse to look. Reach the glowing goal to advance. Avoid red hazards. Fall = respawn.
    </div>
    <div id="stats" class="panel">
      <div>Level: <span id="levelNum">1</span>/5</div>
      <div>Deaths: <span id="deathsNum">0</span></div>
      <button id="btnStart">Click to capture mouse</button>
    </div>
  </div>

  <div id="overlay">
    <div id="message">
      <h2 id="msgTitle">Paused</h2>
      <p id="msgText">Click resume to continue.</p>
      <button id="btnResume">Resume</button>
    </div>
  </div>

  <div id="crosshair" aria-hidden="true"></div>

  <div id="touchControls">
    <div class="stick" id="moveStick" title="Move"></div>
    <div class="jump" id="jumpBtn" title="Jump"></div>
  </div>

  <div id="mobileHint" class="panel">
    Tip: On mobile, drag left circle to move and tap right button to jump. Tilt to look.
  </div>

  <canvas id="game"></canvas>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // --- Basic setup ---
    const canvas = document.getElementById("game");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0f1a);
    const fog = new THREE.Fog(0x0b0f1a, 40, 140);
    scene.fog = fog;

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.05, 500);
    camera.position.set(0, 2, 6);

    // Lighting
    const hemi = new THREE.HemisphereLight(0xbcdcff, 0x0a0a0a, 0.75);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(15, 25, 10);
    dir.castShadow = true;
    dir.shadow.mapSize.set(1024, 1024);
    dir.shadow.camera.near = 1;
    dir.shadow.camera.far = 60;
    scene.add(dir);

    // --- UI ---
    const levelNumEl = document.getElementById("levelNum");
    const deathsNumEl = document.getElementById("deathsNum");
    const btnStart = document.getElementById("btnStart");
    const overlay = document.getElementById("overlay");
    const msgTitle = document.getElementById("msgTitle");
    const msgText = document.getElementById("msgText");
    const btnResume = document.getElementById("btnResume");

    let pointerLocked = false;
    btnStart.addEventListener("click", () => {
      canvas.requestPointerLock();
    });
    document.addEventListener("pointerlockchange", () => {
      pointerLocked = document.pointerLockElement === canvas;
      if (!pointerLocked) {
        overlay.classList.add("show");
        msgTitle.textContent = "Paused";
        msgText.textContent = "Click resume to continue.";
      } else {
        overlay.classList.remove("show");
      }
    });
    btnResume.addEventListener("click", () => {
      canvas.requestPointerLock();
    });

    // --- Player state ---
    const GRAVITY = 22;         // m/s^2
    const MOVE_SPEED = 7;       // m/s
    const AIR_CONTROL = 0.5;    // fraction of control in air
    const JUMP_VELOCITY = 7.5;  // m/s
    const PLAYER_RADIUS = 0.35;
    const player = {
      position: new THREE.Vector3(0, 2, 0),
      velocity: new THREE.Vector3(),
      onGround: false,
      yaw: 0,
      pitch: 0,
    };

    // Camera offset (third-person-lite)
    const camOffset = new THREE.Vector3(0, 0.8, -0.9);

    // Input
    const keys = { w: false, a: false, s: false, d: false, space: false };
    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (k === "w") keys.w = true;
      if (k === "a") keys.a = true;
      if (k === "s") keys.s = true;
      if (k === "d") keys.d = true;
      if (k === " ") keys.space = true;
    });
    window.addEventListener("keyup", (e) => {
      const k = e.key.toLowerCase();
      if (k === "w") keys.w = false;
      if (k === "a") keys.a = false;
      if (k === "s") keys.s = false;
      if (k === "d") keys.d = false;
      if (k === " ") keys.space = false;
    });
    // Mouse look
    window.addEventListener("mousemove", (e) => {
      if (!pointerLocked) return;
      const sensitivity = 0.0025;
      player.yaw -= e.movementX * sensitivity;
      player.pitch -= e.movementY * sensitivity;
      player.pitch = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, player.pitch));
    });

    // --- Level building helpers ---
    const solids = [];    // platforms (safe)
    const hazards = [];   // red kill zones
    const movers = [];    // moving/rotating obstacles
    let goal = null;
    let currentLevel = 1;
    let deaths = 0;

    const matPlatform = new THREE.MeshStandardMaterial({ color: 0x2f3640, roughness: 0.9, metalness: 0.0 });
    const matHazard = new THREE.MeshStandardMaterial({ color: 0xdb2b2b, emissive: 0x330000, roughness: 0.7 });
    const matFriendly = new THREE.MeshStandardMaterial({ color: 0x6ab04a, roughness: 0.8 });
    const matGoal = new THREE.MeshStandardMaterial({ color: 0xf5d76e, emissive: 0x332200, roughness: 0.5, metalness: 0.2 });

    function makeBox(w, h, d, material, castShadow = true, receiveShadow = true) {
      const geo = new THREE.BoxGeometry(w, h, d);
      const mesh = new THREE.Mesh(geo, material);
      mesh.castShadow = castShadow;
      mesh.receiveShadow = receiveShadow;
      return mesh;
    }
    function addPlatform(pos, size) {
      const m = makeBox(size.x, size.y, size.z, matPlatform);
      m.position.copy(pos);
      m.userData.aabb = makeAABBFromMesh(m);
      solids.push(m);
      scene.add(m);
      return m;
    }
    function addHazard(pos, size) {
      const m = makeBox(size.x, size.y, size.z, matHazard);
      m.position.copy(pos);
      m.userData.aabb = makeAABBFromMesh(m);
      hazards.push(m);
      scene.add(m);
      return m;
    }
    function addMover(config) {
      const { type, pos, size, axis, speed, range, rotationSpeed } = config;
      const material = type === "hazard" ? matHazard : matPlatform;
      const m = makeBox(size.x, size.y, size.z, material);
      m.position.copy(pos);
      m.userData.basePos = pos.clone();
      m.userData.type = type;
      m.userData.axis = axis || new THREE.Vector3(1,0,0);
      m.userData.speed = speed || 1.5;
      m.userData.range = range || 4;
      m.userData.rotationSpeed = rotationSpeed || 0;
      m.userData.t = 0;
      m.userData.aabb = makeAABBFromMesh(m);
      movers.push(m);
      scene.add(m);
      return m;
    }
    function addGoal(pos) {
      const g = makeBox(1.2, 1.2, 1.2, matGoal);
      g.position.copy(pos);
      const glow = new THREE.PointLight(0xffd27a, 1.0, 10);
      glow.position.copy(pos).add(new THREE.Vector3(0, 1.2, 0));
      scene.add(glow);
      g.userData.aabb = makeAABBFromMesh(g);
      scene.add(g);
      return g;
    }

    // Ground plane (for visual reference)
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({ color: 0x1c2331, roughness: 1 }));
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.01;
    ground.receiveShadow = true;
    scene.add(ground);

    // Build levels
    function clearLevel() {
      [...solids, ...hazards, ...movers].forEach(m => scene.remove(m));
      solids.length = 0; hazards.length = 0; movers.length = 0;
      if (goal) scene.remove(goal);
      goal = null;
    }

    const levelDefs = [
      // Level 1: Intro — wide platforms, simple jumps
      (spawn=false) => {
        addPlatform(new THREE.Vector3(0, 0, 0), new THREE.Vector3(10, 0.8, 10));
        addPlatform(new THREE.Vector3(0, 0.5, -8), new THREE.Vector3(6, 0.6, 4));
        addPlatform(new THREE.Vector3(0, 1.0, -14), new THREE.Vector3(4, 0.6, 3));
        addHazard(new THREE.Vector3(0, -2, -6), new THREE.Vector3(10, 0.5, 6));
        goal = addGoal(new THREE.Vector3(0, 1.2, -18));
        return new THREE.Vector3(0, 2.0, 4);
      },
      // Level 2: Moving platform across gap
      () => {
        addPlatform(new THREE.Vector3(0, 0, 0), new THREE.Vector3(8, 0.6, 8));
        addHazard(new THREE.Vector3(0, -2, -6), new THREE.Vector3(14, 0.6, 8));
        addMover({
          type: "platform",
          pos: new THREE.Vector3(0, 1.2, -10),
          size: new THREE.Vector3(3.5, 0.5, 2.5),
          axis: new THREE.Vector3(1,0,0),
          speed: 1.6,
          range: 6
        });
        addPlatform(new THREE.Vector3(6, 1.2, -14), new THREE.Vector3(3.5, 0.5, 3));
        goal = addGoal(new THREE.Vector3(6, 1.8, -18));
        return new THREE.Vector3(0, 1.6, 3);
      },
      // Level 3: Rotating beams over hazard
      () => {
        addPlatform(new THREE.Vector3(0, 0, 0), new THREE.Vector3(6, 0.6, 6));
        addHazard(new THREE.Vector3(0, -0.2, -8), new THREE.Vector3(12, 0.4, 12));
        addMover({
          type: "hazard",
          pos: new THREE.Vector3(0, 1.2, -6),
          size: new THREE.Vector3(8, 0.3, 0.5),
          rotationSpeed: 1.2
        });
        addMover({
          type: "hazard",
          pos: new THREE.Vector3(0, 1.2, -10),
          size: new THREE.Vector3(8, 0.3, 0.5),
          rotationSpeed: -1.5
        });
        addPlatform(new THREE.Vector3(0, 1.0, -14), new THREE.Vector3(3, 0.5, 2.5));
        goal = addGoal(new THREE.Vector3(0, 1.8, -18));
        return new THREE.Vector3(0, 1.6, 2.5);
      },
      // Level 4: Narrow stepping stones + fast mover
      () => {
        addPlatform(new THREE.Vector3(0, 0, 0), new THREE.Vector3(5, 0.6, 5));
        const stepsZ = [-6, -9, -12, -15];
        stepsZ.forEach((z, i) => {
          addPlatform(new THREE.Vector3((i % 2 === 0 ? -1.2 : 1.2), 0.8 + i*0.2, z), new THREE.Vector3(1.6, 0.4, 1.6));
        });
        addHazard(new THREE.Vector3(0, -0.6, -10), new THREE.Vector3(10, 0.3, 14));
        addMover({
          type: "hazard",
          pos: new THREE.Vector3(0, 1.2, -10),
          size: new THREE.Vector3(6, 0.4, 0.7),
          axis: new THREE.Vector3(1,0,0),
          speed: 2.3,
          range: 5
        });
        addPlatform(new THREE.Vector3(0, 1.6, -18), new THREE.Vector3(2.5, 0.5, 2.5));
        goal = addGoal(new THREE.Vector3(0, 2.2, -20));
        return new THREE.Vector3(0, 1.5, 2.5);
      },
      // Level 5: Final—long jump, moving target, double rotating hazard
      () => {
        addPlatform(new THREE.Vector3(0, 0, 0), new THREE.Vector3(4, 0.6, 4));
        addHazard(new THREE.Vector3(0, -0.2, -6), new THREE.Vector3(14, 0.4, 16));
        addMover({
          type: "platform",
          pos: new THREE.Vector3(0, 1.4, -10),
          size: new THREE.Vector3(2.2, 0.4, 2.2),
          axis: new THREE.Vector3(1,0,0),
          speed: 2.0,
          range: 8
        });
        addMover({
          type: "hazard",
          pos: new THREE.Vector3(-3, 1.2, -10),
          size: new THREE.Vector3(7, 0.3, 0.6),
          rotationSpeed: 1.8
        });
        addMover({
          type: "hazard",
          pos: new THREE.Vector3(3, 1.2, -10),
          size: new THREE.Vector3(7, 0.3, 0.6),
          rotationSpeed: -2.0
        });
        addPlatform(new THREE.Vector3(0, 1.6, -16), new THREE.Vector3(2.0, 0.4, 2.0));
        addPlatform(new THREE.Vector3(0, 2.0, -20), new THREE.Vector3(2.0, 0.4, 2.0));
        goal = addGoal(new THREE.Vector3(0, 2.6, -22));
        return new THREE.Vector3(0, 1.6, 2.5);
      }
    ];

    function loadLevel(n) {
      clearLevel();
      levelNumEl.textContent = String(n);
      currentLevel = n;
      const spawn = levelDefs[n-1]();
      respawn(spawn);
    }

    function respawn(spawnPos) {
      player.position.copy(spawnPos || new THREE.Vector3(0, 2, 0));
      player.velocity.set(0, 0, 0);
      player.onGround = false;
    }

    // --- Collision helpers (AABB vs sphere) ---
    function makeAABBFromMesh(mesh) {
      const box = new THREE.Box3().setFromObject(mesh);
      return box;
    }
    function updateAABB(mesh) {
      mesh.userData.aabb = makeAABBFromMesh(mesh);
    }
    function sphereAABBCollide(center, radius, aabb) {
      // Find closest point in AABB to sphere center
      const x = Math.max(aabb.min.x, Math.min(center.x, aabb.max.x));
      const y = Math.max(aabb.min.y, Math.min(center.y, aabb.max.y));
      const z = Math.max(aabb.min.z, Math.min(center.z, aabb.max.z));
      const dx = x - center.x, dy = y - center.y, dz = z - center.z;
      const dist2 = dx*dx + dy*dy + dz*dz;
      return dist2 <= radius*radius;
    }

    // --- Game loop ---
    let last = performance.now();
    function animate(now) {
      const dt = Math.min(0.033,
